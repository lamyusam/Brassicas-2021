---
title: "Brassicas_2021"
author: "Benjamin A Taylor"
date: "29/03/2021"
output:   
  html_document:
    code_folding: hide
    self_contained: FALSE
    fig_width: 10
    fig_height: 10 
  pdf_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = F, message = F, warning = F, cache = T, cache.path =  "/home/benjamin/Documents/Brassicas_repo/Brassicas_cache/Cache")
```
```{r load-libraries, eval = TRUE, echo = FALSE, include = FALSE}
# get libraries
basic_libraries <- c("tidyverse",
                     "RColorBrewer",
                     "lme4",
                     "lmerTest",
                     "performance",
                     "see",
                     "factoextra")

for (lib in basic_libraries) {
        if (require(package = lib, character.only = TRUE)) {
                print("Successful")
        } else {
                print("Installing")
                install.packages(lib)
                library(lib, character.only = TRUE )
        }
}
```

Import morphology data and clean up the formatting:

```{r import-data, eval = TRUE, echo = FALSE, include = FALSE}
options(stringsAsFactors = F)
setwd("/home/benjamin/Documents/Brassicas_repo")

# import data
phenodata.gen2 = read.delim("Data/Phenotypic_data/morphology_data_gen2.txt", sep = ",", header = T, row.names = NULL)
colnames(phenodata.gen2)
table(phenodata.gen2$Species)

# remove unused columns
phenodata.gen2 = select(phenodata.gen2, -c("Total_la"))

# change the environment labels to something less verbose
phenodata.gen2$Environment =  ifelse(phenodata.gen2$Environment == "wheat competition", "wheat", "control")

# take note of the most relevant measured variables
measure.vars = c("Days_germ", #days from potting to germination
                 "Height", #max distance from soil to plant
                 "Leaf_length", #base to tip of longest non-cotyledon
                 "Num_leaves", #number of leaves
                 "Sla", #single leaf area of oldest non-cotyledon
                 "Sldw", #single lead dry weight of oldest non-cotyledon
                 #"Sp_la", #specific leaf area
                 "Aboveground_dw", #all biomass above soil
                 #"Day_flowering", #days from germination to flowering
                 "Root_dw" #all biomass below soil
                 #"Total_biomass", #sum of above and below ground biomass
                 #"Root_to_shoot_ratio" #ratio of below to above-ground biomass (I think)
) 

# convert to numeric where applicable
phenodata.gen2.clean =  mutate_at(phenodata.gen2, measure.vars, function(x) as.numeric(as.character(x))) %>%
  select(c("Label_front","Species","Population","Wild_Dom","Environment",measure.vars)) 
```

Wel'll begin with a simple exploration of the  data. The proportion of the samples for which we actually have complete data is actually quite small:

```{r}
phenodata.gen2.clean.brass = phenodata.gen2.clean %>% subset(substr(Species,1,8)=="Brassica")
print(paste0(length(which(complete.cases(phenodata.gen2.clean.brass))),"/",nrow(phenodata.gen2.clean.brass)," of Brassica records are complete"))

phenodata.gen2.clean.raph = phenodata.gen2.clean %>% subset(substr(Species,1,8)=="Raphanus")
print(paste0(length(which(complete.cases(phenodata.gen2.clean.raph))),"/",nrow(phenodata.gen2.clean.raph)," of Raphanus records are complete"))
```
Nonetheless, this sample will hopefully be representative for an initial exploration. Looking at the analyses that Jasmine has generated so far, two things are notable: first, we have a large number of measured morphological characteristics, which means that any stats we generate are hard to interpret and likely to be diminished significantly by FDR correction; and second, the results generated for individual characteristics are inconsistent and marginal. My initial instinct is to look for a way to reduce the dimensionality of the data, so let's try generating PCAs. We'll start with the Brassicas.

We'll begin with a scree plot, which shows that PCs 1 and 2 together explain about two thirds of the data. There's a big drop off in information per component for PCs 3+ so we'll focus on just the first two PCs for now. 

```{r}
phenodata.gen2.clean.compcases = phenodata.gen2.clean[complete.cases(phenodata.gen2.clean),]

##pca for brassicas
# subset to brassicas and complete cases
pca.counts = phenodata.gen2.clean.compcases %>% 
  subset(substr(Species,1,8)=="Brassica") %>%
  remove_rownames() %>%
  column_to_rownames("Label_front") %>%
  select(measure.vars) #%>% 
  #scale() 

#generate PCA object
#NB: pre-scaling is important for PCA, in order to prevent high-variance covariates dominating the PC calculations
data.pca = prcomp(pca.counts,scale. = T)

#generate scree plot
fviz_eig(data.pca)
```

Looking at the loading of these two PCs, we can see that they decompose fairly cleanly into a component that represents leaf size/length/weight, and a second component that represents other metrics related to size and weight. Notably, individuals that germinated more quickly are also larger. We also predict that time to flowering will be loaded in the opposite direction to size, but because we have very few complete cases when including flowering time, those data aren't in this plot. 

```{r}
#visualize PC loadings
fviz_pca_var(data.pca,
             col.var = "contrib", # Color by contributions to the PC
             gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
             repel = TRUE     # Avoid text overlapping
)
```

Now let's plot individuals on these PCs and color according either to species or to wild vs domesticated origins:

```{r}
#plot by species
fviz_pca_ind(data.pca,
             habillage = subset(phenodata.gen2.clean.compcases, substr(Species,1,8)=="Brassica")$Species, #label by spp
             label = F, 
             pointsize = 3.5,
             invisible = "quali", #removes centre point for groups from plot
             ggtheme = theme_gray()) + #grey background makes picking out patterns easier
  scale_shape_manual(values = rep(20,7)) #hacky way of preventing the plot from using different shapes for each group

#plot by environment of origin
fviz_pca_ind(data.pca,
             habillage = subset(phenodata.gen2.clean.compcases, substr(Species,1,8)=="Brassica")$Wild_Dom, #label by spp
             label = F, 
             pointsize = 3.5,
             invisible = "quali", #removes centre point for groups from plot
             ggtheme = theme_gray()) + #grey background makes picking out patterns easier
  scale_shape_manual(values = rep(20,7)) #hacky way of preventing the plot from using different shapes for each group
  
```
We now want to ask whether individuals' assignments along the first two PCs are predicted well by cultivated stats, treatment, or their interaction. Let's begin by checking distributions of the PCs. First with PC1:

```{r}
#append values for first two PCs to pheno data
pca.out = phenodata.gen2.clean.compcases %>% 
  subset(substr(Species,1,8)=="Brassica") %>%
  mutate(pca.counts, PC1 = data.pca$x[,"PC1"], PC2 = data.pca$x[,"PC2"])

#generate an lmm for PC1
PC1.model.gaus = lmer(PC1~Environment + Wild_Dom + Environment:Wild_Dom + (1|Wild_Dom/Population), data=pca.out)

#initial model throws an error so we add a control parameter and also scale the response variable
PC1.model.gaus = lmer(scale(PC1)~Environment + Wild_Dom + Environment:Wild_Dom + (1|Wild_Dom/Population), 
                      data=pca.out, 
                      control = lmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 10000)))
#that helped! Let's check out the model performance- it looks decent
check_model(PC1.model.gaus)

#looking at the output, however, we have no meaningful effects:
summary(PC1.model.gaus)$coefficients
```
Now with PC2:

```{r}
PC2.model.gaus = lmer(scale(PC2)~Environment + Wild_Dom + Environment:Wild_Dom + (1|Wild_Dom/Population), 
                      data=pca.out, 
                      control = lmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 10000)))
#model performance is much worse for this PC
check_model(PC2.model.gaus)

#let's try something different
PC2.model.gaus.log = glmer(scale(PC2)~Environment + Wild_Dom + Environment:Wild_Dom + (1|Wild_Dom/Population), 
                      data=pca.out, 
                      family=gaussian(link = "log"),
                      mustart=pmax(scale(pca.out$PC2),1e-3),
                      control = glmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 10000)))

#this works, but the message 'boundary (singular) fit' indicates either some multicollinearity or alternatively an effect with an estimate close to zero
# looking at the output, it looks like the interaction term with environment and wild_dom might be the culprit
summary(PC2.model.gaus.log)$coefficients

summary(glmer(scale(PC2)~Environment + Wild_Dom + (1|Wild_Dom/Population), 
                      data=pca.out, 
                      family=gaussian(link = "log"),
                      mustart=pmax(scale(pca.out$PC2),1e-3),
                      control = glmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 10000))))
```

